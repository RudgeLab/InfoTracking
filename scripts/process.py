import numpy as np
from skimage.io import imread, imsave
from scipy.ndimage import distance_transform_edt
import matplotlib.pyplot as plt

# Image frame to start from and step between frames
start_frame = 70
step = 1

# Position and velocity arrays from velocimetry
vel = np.load('vel.np.npy')
pos = np.load('pos.np.npy')

# Size of data
nx,ny,nt,_ = vel.shape

# Load the tif image from the microscope
im_all = imread('../10x_1.5x_-5_pAAA_MG_1_MMStack_Pos9.ome.tif')

# Load the mask generated by trainable weka
mask_all = imread('../C2-10x_1.5x_-5_pAAA_MG_1_MMStack_Pos9.ome.mask.tif')
mask_all = mask_all / mask_all.max()

# Make arrays to store results
radpos = np.zeros((nt,nx,ny))
vmag = np.zeros((nt,nx,ny))
edt = np.zeros((nt,1024,1024))

# Process the data and save results
for frame in range(nt):
    print(f'Processing frame {frame}')

    # Subtract drift from velocities
    vel[:,:,frame,0] -= np.nanmean(vel[:,:,frame,0])
    vel[:,:,frame,1] -= np.nanmean(vel[:,:,frame,1])

    # Compute distance of each pixel from colony edge
    edt[frame,:,:] = distance_transform_edt(mask_all[start_frame + frame*step,:,:])

    # Get direction to colony edge as negative of gradient of distance
    gx,gy = np.gradient(edt[frame,:,:])
    gx = -gx[pos[:,:,frame,0].astype(int)+31, pos[:,:,frame,1].astype(int)+31]
    gy = -gy[pos[:,:,frame,0].astype(int)+31, pos[:,:,frame,1].astype(int)+31]

    # Compute magnitude of velocities in radial direction
    vmag[frame,:,:] = vel[:,:,frame,0] * gx + vel[:,:,frame,1] * gy

    # Radial position of each grid square
    radpos[frame,:,:] = edt[frame, pos[:,:,frame,0].astype(int)+31, pos[:,:,frame,1].astype(int)+31]

# Area and estimated radius of colony
area = mask_all[start_frame + frame*step:start_frame + (frame+nt)*step:step,:,:].sum(axis=(1,2))
radius = np.sqrt(area / np.pi)

# Save results
np.save('radpos.npy', radpos)
np.save('edt.npy', edt)
np.save('vmag.npy', vmag)
np.save('area.npy', area)
np.save('radius.npy', radius)
