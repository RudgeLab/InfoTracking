import numpy as np
from skimage.io import imread, imsave
from scipy.ndimage import distance_transform_edt
import matplotlib.pyplot as plt

# Image frame to start from and step between frames
start_frame = 50
step = 1

# Position and velocity arrays from velocimetry
vel = np.load('vel.np.npy')
pos = np.load('pos.np.npy')

# Size of data
nx,ny,nt,_ = vel.shape

# Load the tif image from the microscope
#im_all = imread('../10x_1.5x_-5_pAAA_MG_1_MMStack_Pos9.ome.tif')
#im_all = imread('../Fused_12_13_14_15_1024.bgcorr.tiff')
im_all = imread('../10x_1.5x_-5_pAAA_MG_1_MMStack_Pos8.ome.tif')

# Load the mask generated by trainable weka
#mask_all = imread('../C2-10x_1.5x_-5_pAAA_MG_1_MMStack_Pos9.ome.mask.tif')
mask_all = imread('../C2-10x_1.5x_-5_pAAA_MG_1_MMStack_Pos8_phase.contour.mask.ome.tif')

#mask_all = np.zeros(im_all.shape[:3])
#x,y = np.meshgrid(np.arange(1024), np.arange(632))
#cx,cy = 320,500
#r = np.sqrt((x-cy)**2 + (y-cx)**2)
#mask = r<300
#for frame in range(im_all.shape[0]):
#    mask_all[frame,:,:] = mask
#mask_all = (mask_all==True)*1

# Make arrays to store results
radpos = np.zeros((nt,nx,ny))
vmag = np.zeros((nt,nx,ny))
vrad = np.zeros((nt,nx,ny))
vtheta = np.zeros((nt,nx,ny))
edt = np.zeros((nt,1024,1024))

# Process the data and save results
for frame in range(nt):
    print(f'Processing frame {frame}')

    vx = vel[:,:,frame,0]
    vy = vel[:,:,frame,1]

    # Subtract drift from velocities
    vx -= np.nanmean(vx)
    vy -= np.nanmean(vy)

    # Compute distance of each pixel from colony edge
    edt[frame,:,:] = distance_transform_edt(mask_all[start_frame + frame*step,:,:])
    #edt[frame,:,:] = distance_transform_edt(mask_all[frame*step,:,:])

    # Get direction to colony edge as negative of gradient of distance
    gx,gy = np.gradient(edt[frame,:,:])
    px = pos[:-1,:-1,frame,0]
    py = pos[:-1,:-1,frame,1]
    gx = -gx[px.astype(int)+31, py.astype(int)+31]
    gy = -gy[px.astype(int)+31, py.astype(int)+31]

    # Compute magnitude of velocities in radial direction
    velnorm = np.sqrt(vel[:-1,:-1,frame,0]**2 + vel[:-1,:-1,frame,1]**2)
    gnorm = np.sqrt(gx**2 + gy**2)
    vmag[frame,:-1,:-1] = vel[:-1,:-1,frame,0] * gx + vel[:-1,:-1,frame,1] * gy
    vrad[frame,:-1,:-1] = vmag[frame,:-1,:-1] / velnorm / gnorm
    vperp = vel[:-1,:-1,frame,0] * gy - vel[:-1,:-1,frame,1] * gx
    vtheta[frame,:-1,:-1] = vperp / velnorm / gnorm

    # Radial position of each grid square
    radpos[frame,:-1,:-1] = edt[frame, px.astype(int)+31, py.astype(int)+31]

# Area and estimated radius of colony
#area = mask_all[start_frame:start_frame + nt*step:step,:,:].sum(axis=(1,2))
area = mask_all[:nt*step:step,:,:].sum(axis=(1,2))
radius = np.sqrt(area / np.pi)

# Save results
np.save('radpos.npy', radpos)
np.save('edt.npy', edt)
np.save('vmag.npy', vmag)
np.save('vrad.npy', vrad)
np.save('vtheta.npy', vtheta)
np.save('area.npy', area)
np.save('radius.npy', radius)
