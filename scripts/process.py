import numpy as np
from skimage.io import imread, imsave
from scipy.ndimage import distance_transform_edt
import matplotlib.pyplot as plt

# Image frame to start from and step between frames
start_frame = 50
step = 1

# Position and velocity arrays from velocimetry
vel = np.load('vel.np.npy')
pos = np.load('pos.np.npy')

# Size of data
nx,ny,nt,_ = vel.shape

# Load the tif image from the microscope
#im_all = imread('../10x_1.5x_-5_pAAA_MG_1_MMStack_Pos9.ome.tif')
#im_all = imread('../Fused_12_13_14_15_1024.bgcorr.tiff')
#im_all = imread('../10x_1.5x_-5_pAAA_MG_1_MMStack_Pos8.ome.tif')
#im_all = imread('../../../Microscopy/10x_1.0x_pLPT20_DHL_1_MMStack_Pos0.ome.tif')
im_all = imread('/Volumes/General/Microscopy/200723/Tweez2/10x_1.0x_pLPT20&41_DHL_TiTweez_2_MMStack_Pos4.ome.tif')

# Load the mask generated by trainable weka
#mask_all = imread('../C2-10x_1.5x_-5_pAAA_MG_1_MMStack_Pos9.contour.mask.ome.tif')
#mask_all = imread('../C2-10x_1.5x_-5_pAAA_MG_1_MMStack_Pos8_phase.contour.mask.ome.tif')
#mask_all = imread('../../10x_1.0x_pLPT20_DHL_1_MMStack_Pos0.ome.contour.mask.tif')
mask_all = imread('/Volumes/General/Microscopy/200723/Tweez2/10x_1.0x_pLPT20&41_DHL_TiTweez_2_MMStack_Pos4.ome.tif')
mask_all = mask_all>0

#mask_all = np.zeros(im_all.shape[:3])
x,y = np.meshgrid(np.arange(1024), np.arange(1024))
#cx,cy = 320,500
#r = np.sqrt((x-cy)**2 + (y-cx)**2)
#mask = r<300
#for frame in range(im_all.shape[0]):
#    mask_all[frame,:,:] = mask
#mask_all = (mask_all==True)*1
    
# Make arrays to store results
radpos = np.zeros((nt,nx,ny))
vmag = np.zeros((nt,nx,ny))
vrad = np.zeros((nt,nx,ny))
vtheta = np.zeros((nt,nx,ny))
edt = np.zeros((nt,1024,1024))

# Process the data and save results
for frame in range(nt):
    print(f'Processing frame {frame}')

    mask = mask_all[start_frame + frame*step,:,:]
    cx = x[mask>0].mean()
    cy = y[mask>0].mean()

    vx = vel[:,:,frame,0]
    vy = vel[:,:,frame,1]

    # Subtract drift from velocities
    vx -= np.nanmean(vx)
    vy -= np.nanmean(vy)

    # Compute distance of each pixel from colony edge
    edt[frame,:,:] = distance_transform_edt(mask)
    #edt[frame,:,:] = distance_transform_edt(mask_all[frame*step,:,:])

    # Get direction to colony edge as negative of gradient of distance
    gradx,grady = np.gradient(edt[frame,:,:])
    gradx[mask==0] = np.nan
    grady[mask==0] = np.nan
    px = pos[:,:,frame,0].astype(int)
    py = pos[:,:,frame,1].astype(int)
    pnorm = np.sqrt((px-cx)**2 + (py-cy)**2)

    gx = np.zeros((nx,ny))
    gy = np.zeros((nx,ny))
    for ix in range(nx):
        for iy in range(ny):
            gx[ix,iy] = -np.nanmean(gradx[px[ix,iy]:px[ix,iy]+48, py[ix,iy]:py[ix,iy]+48])
            gy[ix,iy] = -np.nanmean(grady[px[ix,iy]:px[ix,iy]+48, py[ix,iy]:py[ix,iy]+48])
            #radpos[frame,ix,iy] = np.nanmean(edt[frame, px[ix,iy]-32:px[ix,iy]+32, py[ix,iy]-32:py[ix,iy]+32])

    # Compute magnitude of velocities in radial direction
    velnorm = np.sqrt(vx**2 + vy**2)
    gnorm = np.sqrt(gx**2 + gy**2)
    vmag[frame,:,:] = vx * gx + vy * gy
    vrad[frame,:,:] = vmag[frame,:,:] / velnorm / gnorm
    vperp = vx * gy - vy * gx
    vtheta[frame,:,:] = vperp / velnorm / gnorm

    # Radial position of each grid square
    radpos[frame,:,:] = edt[frame, px+24, py+24]

# Area and estimated radius of colony
#area = mask_all[start_frame:start_frame + nt*step:step,:,:].sum(axis=(1,2))
area = mask_all[start_frame:start_frame+nt*step:step,:,:].sum(axis=(1,2))
radius = np.sqrt(area / np.pi)

# Save results
np.save('radpos.npy', radpos)
np.save('edt.npy', edt)
np.save('vmag.npy', vmag)
np.save('vrad.npy', vrad)
np.save('vtheta.npy', vtheta)
np.save('area.npy', area)
np.save('radius.npy', radius)
